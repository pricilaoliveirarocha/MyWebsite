"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sugar-high";
exports.ids = ["vendor-chunks/sugar-high"];
exports.modules = {

/***/ "(ssr)/./node_modules/sugar-high/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/sugar-high/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SugarHigh: () => (/* binding */ SugarHigh),\n/* harmony export */   generate: () => (/* binding */ generate),\n/* harmony export */   highlight: () => (/* binding */ highlight),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n// @ts-check\n\nconst jsxBrackets = new Set(['<', '>', '{', '}', '[', ']'])\nconst keywords = new Set([\n  'for',\n  'do',\n  'while',\n  'if',\n  'else',\n  'return',\n  'function',\n  'var',\n  'let',\n  'const',\n  'true',\n  'false',\n  'undefined',\n  'this',\n  'new',\n  'delete',\n  'typeof',\n  'in',\n  'instanceof',\n  'void',\n  'break',\n  'continue',\n  'switch',\n  'case',\n  'default',\n  'throw',\n  'try',\n  'catch',\n  'finally',\n  'debugger',\n  'with',\n  'yield',\n  'async',\n  'await',\n  'class',\n  'extends',\n  'super',\n  'import',\n  'export',\n  'from',\n  'static',\n])\n\nconst signs = new Set([\n  '+',\n  '-',\n  '*',\n  '/',\n  '%',\n  '=',\n  '!',\n  '&',\n  '|',\n  '^',\n  '~',\n  '!',\n  '?',\n  ':',\n  '.',\n  ',',\n  ';',\n  `'`,\n  '\"',\n  '.',\n  '(',\n  ')',\n  '[',\n  ']',\n  '#',\n  '@',\n  '\\\\',\n  ...jsxBrackets,\n])\n\n\n/**\n *\n * 0  - identifier\n * 1  - keyword\n * 2  - string\n * 3  - Class, number and null\n * 4  - property\n * 5  - entity\n * 6  - jsx literals\n * 7  - sign\n * 8  - comment\n * 9  - break\n * 10 - space\n *\n */\nconst types = /** @type {const} */ ([\n  'identifier',\n  'keyword',\n  'string',\n  'class',\n  'property',\n  'entity',\n  'jsxliterals',\n  'sign',\n  'comment',\n  'break',\n  'space',\n])\nconst [\n  T_IDENTIFIER,\n  T_KEYWORD,\n  T_STRING,\n  T_CLS_NUMBER,\n  T_PROPERTY,\n  T_ENTITY,\n  T_JSX_LITERALS,\n  T_SIGN,\n  T_COMMENT,\n  T_BREAK,\n  T_SPACE,\n] = /** @types {const} */ types.map((_, i) => i)\n\nfunction isSpaces(str) {\n  return /^[^\\S\\r\\n]+$/g.test(str)\n}\n\nfunction isSign(ch) {\n  return signs.has(ch)\n}\n\nfunction encode(str) {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;')\n}\n\nfunction isWord(chr) {\n  return /^[\\w_]+$/.test(chr) || hasUnicode(chr)\n}\n\nfunction isCls(str) {\n  const chr0 = str[0]\n  return isWord(chr0) &&\n    chr0 === chr0.toUpperCase() ||\n    str === 'null'\n}\n\nfunction hasUnicode(s) {\n  return /[^\\u0000-\\u007f]/.test(s);\n}\n\nfunction isAlpha(chr) {\n  return /^[a-zA-Z]$/.test(chr)\n}\n\nfunction isIdentifierChar(chr) {\n  return isAlpha(chr) || hasUnicode(chr)\n}\n\nfunction isIdentifier(str) {\n  return isIdentifierChar(str[0]) && (str.length === 1 || isWord(str.slice(1)))\n}\n\nfunction isStrTemplateChr(chr) {\n  return chr === '`'\n}\n\nfunction isSingleQuotes(chr) {\n  return chr === '\"' || chr === \"'\"\n}\n\nfunction isStringQuotation(chr) {\n  return isSingleQuotes(chr) || isStrTemplateChr(chr)\n}\n\nfunction isCommentStart(str) {\n  str = str.slice(0, 2)\n  return str === '//' || str === '/*'\n}\n\nfunction isRegexStart(str) {\n  return str[0] === '/' && !isCommentStart(str[0] + str[1])\n}\n\n/**\n * @param {string} code\n * @return {Array<[number, string]>}\n */\nfunction tokenize(code) {\n  let current = ''\n  let type = -1\n  /** @type {[number, string]} */\n  let last = [-1, '']\n  /** @type {[number, string]} */\n  let beforeLast = [-2, '']\n  /** @type {Array<[number, string]>} */\n  const tokens = []\n\n  /** @type boolean if entered jsx tag, inside <open tag> or </close tag> */\n  let __jsxEnter = false\n  /**\n   * @type {0 | 1 | 2}\n   * @example\n   * 0 for not in jsx;\n   * 1 for open jsx tag;\n   * 2 for closing jsx tag;\n   **/\n  let __jsxTag = 0\n  let __jsxExpr = false\n\n  // only match paired (open + close) tags, not self-closing tags\n  let __jsxStack = 0\n  const __jsxChild = () => __jsxEnter && !__jsxExpr && !__jsxTag\n  // < __content__ >\n  const inJsxTag = () => __jsxTag && !__jsxChild()\n  // {'__content__'}\n  const inJsxLiterals = () => !__jsxTag && __jsxChild() && !__jsxExpr && __jsxStack > 0\n\n  /** @type {string | null} */\n  let __strQuote = null\n  let __strTemplateExprStack = 0\n  let __strTemplateQuoteStack = 0\n  const inStringQuotes = () => __strQuote !== null\n  const inStrTemplateLiterals = () => (__strTemplateQuoteStack > __strTemplateExprStack)\n  const inStrTemplateExpr = () => __strTemplateQuoteStack > 0 && (__strTemplateQuoteStack === __strTemplateExprStack)\n  const inStringContent = () => inStringQuotes() || inStrTemplateLiterals()\n\n  /**\n   *\n   * @param {string} token\n   * @returns {number}\n   */\n  function classify(token) {\n    const isLineBreak = token === '\\n'\n    // First checking if they're attributes values\n    if (inJsxTag()) {\n      if (inStringQuotes()) {\n        return T_STRING\n      }\n\n      const [, lastToken] = last\n      if (isIdentifier(token)) {\n        // classify jsx open tag\n        if ((lastToken === '<' || lastToken === '</')) \n          return T_ENTITY\n      }\n    }\n    // Then determine if they're jsx literals\n    const isJsxLiterals = inJsxLiterals()\n    if (isJsxLiterals) return T_JSX_LITERALS\n\n    // Determine strings first before other types\n    if (inStringQuotes()) {\n      return T_STRING\n    } else if (keywords.has(token)) {\n      return last[1] === '.' ? T_IDENTIFIER : T_KEYWORD\n    } else if (isLineBreak) {\n      return T_BREAK\n    } else if (isSpaces(token)) {\n      return T_SPACE\n    } else if (token.split('').every(isSign)) {\n      return T_SIGN\n    } else if (isCls(token)) {\n      return inJsxTag() ? T_IDENTIFIER : T_CLS_NUMBER\n    } else {\n      if (isIdentifier(token)) {\n        const isLastPropDot = last[1] === '.' && isIdentifier(beforeLast[1])\n\n        if (!inStringContent() && !isLastPropDot) return T_IDENTIFIER\n        if (isLastPropDot) return T_PROPERTY\n      }\n      return T_STRING\n    }\n  }\n\n  const append = (_type, _token) => {\n    if (_token) {\n      current = _token\n    }\n    if (current) {\n      type = _type || classify(current)\n      /** @type [number, string]  */\n      const pair = [type, current]\n      if (type !== T_SPACE && type !== T_BREAK) {\n        beforeLast = last\n        last = pair\n      }\n      tokens.push(pair)\n    }\n    current = ''\n  }\n  for (let i = 0; i < code.length; i++) {\n    const curr = code[i]\n    const prev = code[i - 1]\n    const next = code[i + 1]\n    const p_c = prev + curr // previous and current\n    const c_n = curr + next // current and next\n\n    // Determine string quotation outside of jsx literals.\n    // Inside jsx literals, string quotation is still part of it.\n    if (isSingleQuotes(curr) && !inJsxLiterals()) {\n      append()\n      if (prev !== `\\\\`) {\n        if (__strQuote && curr === __strQuote) {\n          __strQuote = null\n        } else if (!__strQuote) {\n          __strQuote = curr\n        }\n      }\n\n      append(T_STRING, curr)\n      continue\n    }\n\n    if (!inStrTemplateLiterals()) {\n      if (prev !== '\\\\n' && isStrTemplateChr(curr)) {\n        append()\n        append(T_STRING, curr)\n        __strTemplateQuoteStack++\n        continue\n      }\n    }\n\n    if (inStrTemplateLiterals()) {\n      if (prev !== '\\\\n' && isStrTemplateChr(curr)) {\n        if (__strTemplateQuoteStack > 0) {\n          append()\n          __strTemplateQuoteStack--\n          append(T_STRING, curr)\n          continue\n        }\n      }\n\n      if (c_n === '${') {\n        __strTemplateExprStack++\n        append(T_STRING)\n        append(T_SIGN, c_n)\n        i++\n        continue\n      }\n    }\n\n    if (inStrTemplateExpr() && curr === '}') {\n      append()\n      __strTemplateExprStack--\n      append(T_SIGN, curr)\n      continue\n    }\n\n    if (__jsxChild()) {\n      if (curr === '{') {\n        append()\n        append(T_SIGN, curr)\n        __jsxExpr = true\n        continue\n      }\n    }\n\n    if (__jsxEnter) {\n      // <: open tag sign\n      // new '<' not inside jsx\n      if (!__jsxTag && curr === '<') {\n        append()\n        if (next === '/') {\n          // close tag\n          __jsxTag = 2\n          current = c_n\n          i++\n        } else {\n          // open tag\n          __jsxTag = 1\n          current = curr\n        }\n        append(T_SIGN)\n        continue\n      }\n      if (__jsxTag) {\n        // >: open tag close sign or closing tag closing sign\n        // and it's not `=>` or `/>`\n        // `curr` could be `>` or `/`\n        if ((curr === '>' && !'/='.includes(prev))) {\n          append()\n          if (__jsxTag === 1) {\n            __jsxTag = 0\n            __jsxStack++\n          } else {\n            __jsxTag = 0\n            __jsxEnter = false\n          }\n          append(T_SIGN, curr)\n          continue\n        }\n\n        // >: tag self close sign or close tag sign\n        if (c_n === '/>' || c_n === '</') {\n          // if current token is not part of close tag sign, push it first\n          if (current !== '<' && current !== '/') {\n            append()\n          }\n\n          if (c_n === '/>') {\n            __jsxTag = 0\n          } else {\n            // is '</'\n            __jsxStack--\n          }\n\n          if (!__jsxStack)\n            __jsxEnter = false\n\n          current = c_n\n          i++\n          append(T_SIGN)\n          continue\n        }\n\n        // <: open tag sign\n        if (curr === '<') {\n          append()\n          current = curr\n          append(T_SIGN)\n          continue\n        }\n\n        // jsx property\n        // `-` in data-prop\n        if (next === '-'  && !inStringContent() && !inJsxLiterals()) {\n          if (current) {\n            append(T_PROPERTY, current + curr + next)\n            i += 1\n            continue\n          }\n        }\n        // `=` in property=<value>\n        if (next === '=' && !inStringContent()) {\n          const prop = current ? (current + curr) : curr\n          if (isIdentifier(prop)) {\n            current = prop\n            append(T_PROPERTY)\n          }\n          continue\n        }\n      }\n    }\n\n    // if it's not in a jsx tag declaration or a string, close child if next is jsx close tag\n    if (!__jsxTag && (curr === '<' && isIdentifierChar(next) || c_n === '</')) {\n      __jsxTag = next === '/' ? 2 : 1\n\n      // current and next char can form a jsx open or close tag\n      if (curr === '<' && (next === '/' || isAlpha(next))) {\n        __jsxEnter = true\n      }\n    }\n\n    const isQuotationChar = isStringQuotation(curr)\n    const isStringTemplateLiterals = inStrTemplateLiterals()\n    const isRegexChar = !__jsxEnter && isRegexStart(c_n)\n    const isJsxLiterals = inJsxLiterals()\n\n    // string quotation\n    if (isQuotationChar || isStringTemplateLiterals || isSingleQuotes(__strQuote)) {\n      current += curr\n    } else if (isRegexChar) {\n      append()\n      const [lastType, lastToken] = last\n      // Special cases that are not considered as regex:\n      // * (expr1) / expr2: `)` before `/` operator is still in expression\n      // * <non comment start>/ expr: non comment start before `/` is not regex\n      if (\n        isRegexChar &&\n        lastType !== -1 &&\n        !(\n          (lastType === T_SIGN && ')' !== lastToken) ||\n          lastType === T_COMMENT\n        )\n      ) {\n        current = curr\n        append()\n        continue\n      }\n\n      const start = i++\n\n      // end of line of end of file\n      const isEof = () => i >= code.length\n      const isEol = () => isEof() || code[i] === '\\n'\n\n      let foundClose = false\n      // regex\n      for (; !isEol(); i++) {\n        if (code[i] === '/' && code[i - 1] !== '\\\\') {\n          foundClose = true\n          // append regex flags\n          while (start !== i && /^[a-z]$/.test(code[i + 1]) && !isEol()) {\n            i++\n          }\n          break\n        }\n      }\n      if (start !== i && foundClose) {\n        // If current line is fully closed with string quotes or regex slashes,\n        // add them to tokens\n        current = code.slice(start, i + 1)\n        append(T_STRING)\n      } else {\n        // If it doesn't match any of the above, just leave it as operator and move on\n        current = curr\n        append()\n        i = start\n      }\n    } else if (isCommentStart(c_n)) {\n      append()\n      const start = i\n      if (next === '/') {\n        for (; i < code.length && code[i] !== '\\n'; i++);\n      } else {\n        for (; i < code.length && code[i - 1] + code[i] !== '*/'; i++);\n      }\n      current = code.slice(start, i + 1)\n      append(T_COMMENT)\n    } else if (curr === ' ' || curr === '\\n') {\n      if (\n        curr === ' ' &&\n        (\n          (isSpaces(current) || !current) ||\n          isJsxLiterals\n        )\n      ) {\n        current += curr\n        if (next === '<') {\n          append()\n        }\n      } else {\n        append()\n        current = curr\n        append()\n      }\n    } else {\n      if (__jsxExpr && curr === '}') {\n        append()\n        current = curr\n        append()\n        __jsxExpr = false\n      } else if (\n        // it's jsx literals and is not a jsx bracket\n        (isJsxLiterals && !jsxBrackets.has(curr)) ||\n        // same type char as previous one in current token\n        ((isWord(curr) === isWord(current[current.length - 1]) || __jsxChild()) && !signs.has(curr))\n      ) {\n        current += curr\n      } else {\n        if (p_c === '</') {\n          current = p_c\n        }\n        append()\n\n        if (p_c !== '</') {\n          current = curr\n\n        }\n        if ((c_n === '</' || c_n === '/>')) {\n          current = c_n\n          append()\n          i++\n        }\n        else if (jsxBrackets.has(curr)) append()\n      }\n    }\n  }\n\n  append()\n\n  return tokens\n}\n\n/**\n * @param {Array<[number, string]>} tokens\n * @return {Array<any>}\n */\nfunction generate(tokens) {\n  const lines = []\n  /**\n   * @param {any} children\n   * \n   */\n  const createLine = (children) => \n    // generateType === 'html'\n      // ? `<span class=\"sh__line\">${content}</span>`\n      ({\n        type: 'element',\n        tagName: 'span',\n        children,\n        properties: {\n          className: 'sh__line',\n        },\n      })\n\n  /**\n   * @param {Array<[number, string]>} tokens\n   * @returns {void}\n   */\n  function flushLine(tokens) {\n    /** @type {Array<any>} */\n    const lineTokens = (\n      tokens\n        .map(([type, value]) => (\n          {\n            type: 'element',\n            tagName: 'span',\n            children: [{\n              type: 'text',\n              value: value, // to encode\n            }],\n            properties: {\n              className: `sh__token--${types[type]}`,\n              style: `color: var(--sh-${types[type]})`,\n            },\n          }\n        ))\n    )\n    lines.push(createLine(lineTokens))\n  }\n  /** @type {Array<[number, string]>} */\n  const lineTokens = []\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n    const [type, value] = token\n    if (type !== T_BREAK) {\n      // Divide multi-line token into multi-line code\n      if (value.includes('\\n')) {\n        const lines = value.split('\\n')\n        for (let j = 0; j < lines.length; j++) {\n          lineTokens.push([type, lines[j]])\n          if (j < lines.length - 1) {\n            flushLine(lineTokens)\n            lineTokens.length = 0\n          }\n        }\n      } else {\n        lineTokens.push(token)\n      }\n    } else {\n      lineTokens.push([type, ''])\n      flushLine(lineTokens)\n      lineTokens.length = 0\n    }\n  }\n\n  if (lineTokens.length)\n    flushLine(lineTokens)\n\n  return lines\n}\n\nfunction toHtml(lines) {\n  return lines\n    .map(line => {\n      const { tagName: lineTag } = line\n      const tokens = line.children\n        .map(child => {\n          const { tagName, children, properties } = child\n          return `<${tagName} class=\"${\n            properties.className\n          }\" style=\"${\n            properties.style\n          }\">${encode(children[0].value)}</${tagName}>`\n        })\n        .join('')\n      return `<${lineTag} class=\"${line.properties.className}\">${tokens}</${lineTag}>`\n    })\n    .join('\\n')\n}\n\n/**\n *\n * @param {string} code\n * @returns {string}\n */\nfunction highlight(code) {\n  const tokens = tokenize(code)\n  const lines = generate(tokens)\n  const output = toHtml(lines)\n  return output\n}\n\n// namespace\nconst SugarHigh = /** @type {const} */ {\n  TokenTypes: types,\n  TokenMap: new Map(types.map((type, i) => [type, i])),\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3VnYXItaGlnaC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBLHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTzs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7QUFDcEQsUUFBUTtBQUNSLGVBQWUsbURBQW1EO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRCx3Q0FBd0MsWUFBWTtBQUNwRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xELHFCQUFxQixTQUFTO0FBQzlCO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVyxJQUFJLDBCQUEwQixJQUFJLFFBQVE7QUFDckQsU0FBUztBQUNUO0FBQ0EsaUJBQWlCLFNBQVMsU0FBUywwQkFBMEIsSUFBSSxPQUFPLElBQUksUUFBUTtBQUNwRixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTs7QUFPQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaWNpbGEtYmxvZy8uL25vZGVfbW9kdWxlcy9zdWdhci1oaWdoL2xpYi9pbmRleC5qcz9jYzE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1jaGVja1xuXG5jb25zdCBqc3hCcmFja2V0cyA9IG5ldyBTZXQoWyc8JywgJz4nLCAneycsICd9JywgJ1snLCAnXSddKVxuY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KFtcbiAgJ2ZvcicsXG4gICdkbycsXG4gICd3aGlsZScsXG4gICdpZicsXG4gICdlbHNlJyxcbiAgJ3JldHVybicsXG4gICdmdW5jdGlvbicsXG4gICd2YXInLFxuICAnbGV0JyxcbiAgJ2NvbnN0JyxcbiAgJ3RydWUnLFxuICAnZmFsc2UnLFxuICAndW5kZWZpbmVkJyxcbiAgJ3RoaXMnLFxuICAnbmV3JyxcbiAgJ2RlbGV0ZScsXG4gICd0eXBlb2YnLFxuICAnaW4nLFxuICAnaW5zdGFuY2VvZicsXG4gICd2b2lkJyxcbiAgJ2JyZWFrJyxcbiAgJ2NvbnRpbnVlJyxcbiAgJ3N3aXRjaCcsXG4gICdjYXNlJyxcbiAgJ2RlZmF1bHQnLFxuICAndGhyb3cnLFxuICAndHJ5JyxcbiAgJ2NhdGNoJyxcbiAgJ2ZpbmFsbHknLFxuICAnZGVidWdnZXInLFxuICAnd2l0aCcsXG4gICd5aWVsZCcsXG4gICdhc3luYycsXG4gICdhd2FpdCcsXG4gICdjbGFzcycsXG4gICdleHRlbmRzJyxcbiAgJ3N1cGVyJyxcbiAgJ2ltcG9ydCcsXG4gICdleHBvcnQnLFxuICAnZnJvbScsXG4gICdzdGF0aWMnLFxuXSlcblxuY29uc3Qgc2lnbnMgPSBuZXcgU2V0KFtcbiAgJysnLFxuICAnLScsXG4gICcqJyxcbiAgJy8nLFxuICAnJScsXG4gICc9JyxcbiAgJyEnLFxuICAnJicsXG4gICd8JyxcbiAgJ14nLFxuICAnficsXG4gICchJyxcbiAgJz8nLFxuICAnOicsXG4gICcuJyxcbiAgJywnLFxuICAnOycsXG4gIGAnYCxcbiAgJ1wiJyxcbiAgJy4nLFxuICAnKCcsXG4gICcpJyxcbiAgJ1snLFxuICAnXScsXG4gICcjJyxcbiAgJ0AnLFxuICAnXFxcXCcsXG4gIC4uLmpzeEJyYWNrZXRzLFxuXSlcblxuXG4vKipcbiAqXG4gKiAwICAtIGlkZW50aWZpZXJcbiAqIDEgIC0ga2V5d29yZFxuICogMiAgLSBzdHJpbmdcbiAqIDMgIC0gQ2xhc3MsIG51bWJlciBhbmQgbnVsbFxuICogNCAgLSBwcm9wZXJ0eVxuICogNSAgLSBlbnRpdHlcbiAqIDYgIC0ganN4IGxpdGVyYWxzXG4gKiA3ICAtIHNpZ25cbiAqIDggIC0gY29tbWVudFxuICogOSAgLSBicmVha1xuICogMTAgLSBzcGFjZVxuICpcbiAqL1xuY29uc3QgdHlwZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuICAnaWRlbnRpZmllcicsXG4gICdrZXl3b3JkJyxcbiAgJ3N0cmluZycsXG4gICdjbGFzcycsXG4gICdwcm9wZXJ0eScsXG4gICdlbnRpdHknLFxuICAnanN4bGl0ZXJhbHMnLFxuICAnc2lnbicsXG4gICdjb21tZW50JyxcbiAgJ2JyZWFrJyxcbiAgJ3NwYWNlJyxcbl0pXG5jb25zdCBbXG4gIFRfSURFTlRJRklFUixcbiAgVF9LRVlXT1JELFxuICBUX1NUUklORyxcbiAgVF9DTFNfTlVNQkVSLFxuICBUX1BST1BFUlRZLFxuICBUX0VOVElUWSxcbiAgVF9KU1hfTElURVJBTFMsXG4gIFRfU0lHTixcbiAgVF9DT01NRU5ULFxuICBUX0JSRUFLLFxuICBUX1NQQUNFLFxuXSA9IC8qKiBAdHlwZXMge2NvbnN0fSAqLyB0eXBlcy5tYXAoKF8sIGkpID0+IGkpXG5cbmZ1bmN0aW9uIGlzU3BhY2VzKHN0cikge1xuICByZXR1cm4gL15bXlxcU1xcclxcbl0rJC9nLnRlc3Qoc3RyKVxufVxuXG5mdW5jdGlvbiBpc1NpZ24oY2gpIHtcbiAgcmV0dXJuIHNpZ25zLmhhcyhjaClcbn1cblxuZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAucmVwbGFjZSgvJy9nLCAnJiMwMzk7Jylcbn1cblxuZnVuY3Rpb24gaXNXb3JkKGNocikge1xuICByZXR1cm4gL15bXFx3X10rJC8udGVzdChjaHIpIHx8IGhhc1VuaWNvZGUoY2hyKVxufVxuXG5mdW5jdGlvbiBpc0NscyhzdHIpIHtcbiAgY29uc3QgY2hyMCA9IHN0clswXVxuICByZXR1cm4gaXNXb3JkKGNocjApICYmXG4gICAgY2hyMCA9PT0gY2hyMC50b1VwcGVyQ2FzZSgpIHx8XG4gICAgc3RyID09PSAnbnVsbCdcbn1cblxuZnVuY3Rpb24gaGFzVW5pY29kZShzKSB7XG4gIHJldHVybiAvW15cXHUwMDAwLVxcdTAwN2ZdLy50ZXN0KHMpO1xufVxuXG5mdW5jdGlvbiBpc0FscGhhKGNocikge1xuICByZXR1cm4gL15bYS16QS1aXSQvLnRlc3QoY2hyKVxufVxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNocikge1xuICByZXR1cm4gaXNBbHBoYShjaHIpIHx8IGhhc1VuaWNvZGUoY2hyKVxufVxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXIoc3RyKSB7XG4gIHJldHVybiBpc0lkZW50aWZpZXJDaGFyKHN0clswXSkgJiYgKHN0ci5sZW5ndGggPT09IDEgfHwgaXNXb3JkKHN0ci5zbGljZSgxKSkpXG59XG5cbmZ1bmN0aW9uIGlzU3RyVGVtcGxhdGVDaHIoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09ICdgJ1xufVxuXG5mdW5jdGlvbiBpc1NpbmdsZVF1b3RlcyhjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gJ1wiJyB8fCBjaHIgPT09IFwiJ1wiXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nUXVvdGF0aW9uKGNocikge1xuICByZXR1cm4gaXNTaW5nbGVRdW90ZXMoY2hyKSB8fCBpc1N0clRlbXBsYXRlQ2hyKGNocilcbn1cblxuZnVuY3Rpb24gaXNDb21tZW50U3RhcnQoc3RyKSB7XG4gIHN0ciA9IHN0ci5zbGljZSgwLCAyKVxuICByZXR1cm4gc3RyID09PSAnLy8nIHx8IHN0ciA9PT0gJy8qJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ2V4U3RhcnQoc3RyKSB7XG4gIHJldHVybiBzdHJbMF0gPT09ICcvJyAmJiAhaXNDb21tZW50U3RhcnQoc3RyWzBdICsgc3RyWzFdKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gKiBAcmV0dXJuIHtBcnJheTxbbnVtYmVyLCBzdHJpbmddPn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemUoY29kZSkge1xuICBsZXQgY3VycmVudCA9ICcnXG4gIGxldCB0eXBlID0gLTFcbiAgLyoqIEB0eXBlIHtbbnVtYmVyLCBzdHJpbmddfSAqL1xuICBsZXQgbGFzdCA9IFstMSwgJyddXG4gIC8qKiBAdHlwZSB7W251bWJlciwgc3RyaW5nXX0gKi9cbiAgbGV0IGJlZm9yZUxhc3QgPSBbLTIsICcnXVxuICAvKiogQHR5cGUge0FycmF5PFtudW1iZXIsIHN0cmluZ10+fSAqL1xuICBjb25zdCB0b2tlbnMgPSBbXVxuXG4gIC8qKiBAdHlwZSBib29sZWFuIGlmIGVudGVyZWQganN4IHRhZywgaW5zaWRlIDxvcGVuIHRhZz4gb3IgPC9jbG9zZSB0YWc+ICovXG4gIGxldCBfX2pzeEVudGVyID0gZmFsc2VcbiAgLyoqXG4gICAqIEB0eXBlIHswIHwgMSB8IDJ9XG4gICAqIEBleGFtcGxlXG4gICAqIDAgZm9yIG5vdCBpbiBqc3g7XG4gICAqIDEgZm9yIG9wZW4ganN4IHRhZztcbiAgICogMiBmb3IgY2xvc2luZyBqc3ggdGFnO1xuICAgKiovXG4gIGxldCBfX2pzeFRhZyA9IDBcbiAgbGV0IF9fanN4RXhwciA9IGZhbHNlXG5cbiAgLy8gb25seSBtYXRjaCBwYWlyZWQgKG9wZW4gKyBjbG9zZSkgdGFncywgbm90IHNlbGYtY2xvc2luZyB0YWdzXG4gIGxldCBfX2pzeFN0YWNrID0gMFxuICBjb25zdCBfX2pzeENoaWxkID0gKCkgPT4gX19qc3hFbnRlciAmJiAhX19qc3hFeHByICYmICFfX2pzeFRhZ1xuICAvLyA8IF9fY29udGVudF9fID5cbiAgY29uc3QgaW5Kc3hUYWcgPSAoKSA9PiBfX2pzeFRhZyAmJiAhX19qc3hDaGlsZCgpXG4gIC8vIHsnX19jb250ZW50X18nfVxuICBjb25zdCBpbkpzeExpdGVyYWxzID0gKCkgPT4gIV9fanN4VGFnICYmIF9fanN4Q2hpbGQoKSAmJiAhX19qc3hFeHByICYmIF9fanN4U3RhY2sgPiAwXG5cbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCBudWxsfSAqL1xuICBsZXQgX19zdHJRdW90ZSA9IG51bGxcbiAgbGV0IF9fc3RyVGVtcGxhdGVFeHByU3RhY2sgPSAwXG4gIGxldCBfX3N0clRlbXBsYXRlUXVvdGVTdGFjayA9IDBcbiAgY29uc3QgaW5TdHJpbmdRdW90ZXMgPSAoKSA9PiBfX3N0clF1b3RlICE9PSBudWxsXG4gIGNvbnN0IGluU3RyVGVtcGxhdGVMaXRlcmFscyA9ICgpID0+IChfX3N0clRlbXBsYXRlUXVvdGVTdGFjayA+IF9fc3RyVGVtcGxhdGVFeHByU3RhY2spXG4gIGNvbnN0IGluU3RyVGVtcGxhdGVFeHByID0gKCkgPT4gX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2sgPiAwICYmIChfX3N0clRlbXBsYXRlUXVvdGVTdGFjayA9PT0gX19zdHJUZW1wbGF0ZUV4cHJTdGFjaylcbiAgY29uc3QgaW5TdHJpbmdDb250ZW50ID0gKCkgPT4gaW5TdHJpbmdRdW90ZXMoKSB8fCBpblN0clRlbXBsYXRlTGl0ZXJhbHMoKVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGNsYXNzaWZ5KHRva2VuKSB7XG4gICAgY29uc3QgaXNMaW5lQnJlYWsgPSB0b2tlbiA9PT0gJ1xcbidcbiAgICAvLyBGaXJzdCBjaGVja2luZyBpZiB0aGV5J3JlIGF0dHJpYnV0ZXMgdmFsdWVzXG4gICAgaWYgKGluSnN4VGFnKCkpIHtcbiAgICAgIGlmIChpblN0cmluZ1F1b3RlcygpKSB7XG4gICAgICAgIHJldHVybiBUX1NUUklOR1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbLCBsYXN0VG9rZW5dID0gbGFzdFxuICAgICAgaWYgKGlzSWRlbnRpZmllcih0b2tlbikpIHtcbiAgICAgICAgLy8gY2xhc3NpZnkganN4IG9wZW4gdGFnXG4gICAgICAgIGlmICgobGFzdFRva2VuID09PSAnPCcgfHwgbGFzdFRva2VuID09PSAnPC8nKSkgXG4gICAgICAgICAgcmV0dXJuIFRfRU5USVRZXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFRoZW4gZGV0ZXJtaW5lIGlmIHRoZXkncmUganN4IGxpdGVyYWxzXG4gICAgY29uc3QgaXNKc3hMaXRlcmFscyA9IGluSnN4TGl0ZXJhbHMoKVxuICAgIGlmIChpc0pzeExpdGVyYWxzKSByZXR1cm4gVF9KU1hfTElURVJBTFNcblxuICAgIC8vIERldGVybWluZSBzdHJpbmdzIGZpcnN0IGJlZm9yZSBvdGhlciB0eXBlc1xuICAgIGlmIChpblN0cmluZ1F1b3RlcygpKSB7XG4gICAgICByZXR1cm4gVF9TVFJJTkdcbiAgICB9IGVsc2UgaWYgKGtleXdvcmRzLmhhcyh0b2tlbikpIHtcbiAgICAgIHJldHVybiBsYXN0WzFdID09PSAnLicgPyBUX0lERU5USUZJRVIgOiBUX0tFWVdPUkRcbiAgICB9IGVsc2UgaWYgKGlzTGluZUJyZWFrKSB7XG4gICAgICByZXR1cm4gVF9CUkVBS1xuICAgIH0gZWxzZSBpZiAoaXNTcGFjZXModG9rZW4pKSB7XG4gICAgICByZXR1cm4gVF9TUEFDRVxuICAgIH0gZWxzZSBpZiAodG9rZW4uc3BsaXQoJycpLmV2ZXJ5KGlzU2lnbikpIHtcbiAgICAgIHJldHVybiBUX1NJR05cbiAgICB9IGVsc2UgaWYgKGlzQ2xzKHRva2VuKSkge1xuICAgICAgcmV0dXJuIGluSnN4VGFnKCkgPyBUX0lERU5USUZJRVIgOiBUX0NMU19OVU1CRVJcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzSWRlbnRpZmllcih0b2tlbikpIHtcbiAgICAgICAgY29uc3QgaXNMYXN0UHJvcERvdCA9IGxhc3RbMV0gPT09ICcuJyAmJiBpc0lkZW50aWZpZXIoYmVmb3JlTGFzdFsxXSlcblxuICAgICAgICBpZiAoIWluU3RyaW5nQ29udGVudCgpICYmICFpc0xhc3RQcm9wRG90KSByZXR1cm4gVF9JREVOVElGSUVSXG4gICAgICAgIGlmIChpc0xhc3RQcm9wRG90KSByZXR1cm4gVF9QUk9QRVJUWVxuICAgICAgfVxuICAgICAgcmV0dXJuIFRfU1RSSU5HXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYXBwZW5kID0gKF90eXBlLCBfdG9rZW4pID0+IHtcbiAgICBpZiAoX3Rva2VuKSB7XG4gICAgICBjdXJyZW50ID0gX3Rva2VuXG4gICAgfVxuICAgIGlmIChjdXJyZW50KSB7XG4gICAgICB0eXBlID0gX3R5cGUgfHwgY2xhc3NpZnkoY3VycmVudClcbiAgICAgIC8qKiBAdHlwZSBbbnVtYmVyLCBzdHJpbmddICAqL1xuICAgICAgY29uc3QgcGFpciA9IFt0eXBlLCBjdXJyZW50XVxuICAgICAgaWYgKHR5cGUgIT09IFRfU1BBQ0UgJiYgdHlwZSAhPT0gVF9CUkVBSykge1xuICAgICAgICBiZWZvcmVMYXN0ID0gbGFzdFxuICAgICAgICBsYXN0ID0gcGFpclxuICAgICAgfVxuICAgICAgdG9rZW5zLnB1c2gocGFpcilcbiAgICB9XG4gICAgY3VycmVudCA9ICcnXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VyciA9IGNvZGVbaV1cbiAgICBjb25zdCBwcmV2ID0gY29kZVtpIC0gMV1cbiAgICBjb25zdCBuZXh0ID0gY29kZVtpICsgMV1cbiAgICBjb25zdCBwX2MgPSBwcmV2ICsgY3VyciAvLyBwcmV2aW91cyBhbmQgY3VycmVudFxuICAgIGNvbnN0IGNfbiA9IGN1cnIgKyBuZXh0IC8vIGN1cnJlbnQgYW5kIG5leHRcblxuICAgIC8vIERldGVybWluZSBzdHJpbmcgcXVvdGF0aW9uIG91dHNpZGUgb2YganN4IGxpdGVyYWxzLlxuICAgIC8vIEluc2lkZSBqc3ggbGl0ZXJhbHMsIHN0cmluZyBxdW90YXRpb24gaXMgc3RpbGwgcGFydCBvZiBpdC5cbiAgICBpZiAoaXNTaW5nbGVRdW90ZXMoY3VycikgJiYgIWluSnN4TGl0ZXJhbHMoKSkge1xuICAgICAgYXBwZW5kKClcbiAgICAgIGlmIChwcmV2ICE9PSBgXFxcXGApIHtcbiAgICAgICAgaWYgKF9fc3RyUXVvdGUgJiYgY3VyciA9PT0gX19zdHJRdW90ZSkge1xuICAgICAgICAgIF9fc3RyUXVvdGUgPSBudWxsXG4gICAgICAgIH0gZWxzZSBpZiAoIV9fc3RyUXVvdGUpIHtcbiAgICAgICAgICBfX3N0clF1b3RlID0gY3VyclxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFwcGVuZChUX1NUUklORywgY3VycilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKCFpblN0clRlbXBsYXRlTGl0ZXJhbHMoKSkge1xuICAgICAgaWYgKHByZXYgIT09ICdcXFxcbicgJiYgaXNTdHJUZW1wbGF0ZUNocihjdXJyKSkge1xuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBhcHBlbmQoVF9TVFJJTkcsIGN1cnIpXG4gICAgICAgIF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5TdHJUZW1wbGF0ZUxpdGVyYWxzKCkpIHtcbiAgICAgIGlmIChwcmV2ICE9PSAnXFxcXG4nICYmIGlzU3RyVGVtcGxhdGVDaHIoY3VycikpIHtcbiAgICAgICAgaWYgKF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrID4gMCkge1xuICAgICAgICAgIGFwcGVuZCgpXG4gICAgICAgICAgX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2stLVxuICAgICAgICAgIGFwcGVuZChUX1NUUklORywgY3VycilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjX24gPT09ICckeycpIHtcbiAgICAgICAgX19zdHJUZW1wbGF0ZUV4cHJTdGFjaysrXG4gICAgICAgIGFwcGVuZChUX1NUUklORylcbiAgICAgICAgYXBwZW5kKFRfU0lHTiwgY19uKVxuICAgICAgICBpKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5TdHJUZW1wbGF0ZUV4cHIoKSAmJiBjdXJyID09PSAnfScpIHtcbiAgICAgIGFwcGVuZCgpXG4gICAgICBfX3N0clRlbXBsYXRlRXhwclN0YWNrLS1cbiAgICAgIGFwcGVuZChUX1NJR04sIGN1cnIpXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChfX2pzeENoaWxkKCkpIHtcbiAgICAgIGlmIChjdXJyID09PSAneycpIHtcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgYXBwZW5kKFRfU0lHTiwgY3VycilcbiAgICAgICAgX19qc3hFeHByID0gdHJ1ZVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfX2pzeEVudGVyKSB7XG4gICAgICAvLyA8OiBvcGVuIHRhZyBzaWduXG4gICAgICAvLyBuZXcgJzwnIG5vdCBpbnNpZGUganN4XG4gICAgICBpZiAoIV9fanN4VGFnICYmIGN1cnIgPT09ICc8Jykge1xuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBpZiAobmV4dCA9PT0gJy8nKSB7XG4gICAgICAgICAgLy8gY2xvc2UgdGFnXG4gICAgICAgICAgX19qc3hUYWcgPSAyXG4gICAgICAgICAgY3VycmVudCA9IGNfblxuICAgICAgICAgIGkrK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG9wZW4gdGFnXG4gICAgICAgICAgX19qc3hUYWcgPSAxXG4gICAgICAgICAgY3VycmVudCA9IGN1cnJcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmQoVF9TSUdOKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKF9fanN4VGFnKSB7XG4gICAgICAgIC8vID46IG9wZW4gdGFnIGNsb3NlIHNpZ24gb3IgY2xvc2luZyB0YWcgY2xvc2luZyBzaWduXG4gICAgICAgIC8vIGFuZCBpdCdzIG5vdCBgPT5gIG9yIGAvPmBcbiAgICAgICAgLy8gYGN1cnJgIGNvdWxkIGJlIGA+YCBvciBgL2BcbiAgICAgICAgaWYgKChjdXJyID09PSAnPicgJiYgIScvPScuaW5jbHVkZXMocHJldikpKSB7XG4gICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgICBpZiAoX19qc3hUYWcgPT09IDEpIHtcbiAgICAgICAgICAgIF9fanN4VGFnID0gMFxuICAgICAgICAgICAgX19qc3hTdGFjaysrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9fanN4VGFnID0gMFxuICAgICAgICAgICAgX19qc3hFbnRlciA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIGFwcGVuZChUX1NJR04sIGN1cnIpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vID46IHRhZyBzZWxmIGNsb3NlIHNpZ24gb3IgY2xvc2UgdGFnIHNpZ25cbiAgICAgICAgaWYgKGNfbiA9PT0gJy8+JyB8fCBjX24gPT09ICc8LycpIHtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHRva2VuIGlzIG5vdCBwYXJ0IG9mIGNsb3NlIHRhZyBzaWduLCBwdXNoIGl0IGZpcnN0XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09ICc8JyAmJiBjdXJyZW50ICE9PSAnLycpIHtcbiAgICAgICAgICAgIGFwcGVuZCgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNfbiA9PT0gJy8+Jykge1xuICAgICAgICAgICAgX19qc3hUYWcgPSAwXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlzICc8LydcbiAgICAgICAgICAgIF9fanN4U3RhY2stLVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghX19qc3hTdGFjaylcbiAgICAgICAgICAgIF9fanN4RW50ZXIgPSBmYWxzZVxuXG4gICAgICAgICAgY3VycmVudCA9IGNfblxuICAgICAgICAgIGkrK1xuICAgICAgICAgIGFwcGVuZChUX1NJR04pXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDw6IG9wZW4gdGFnIHNpZ25cbiAgICAgICAgaWYgKGN1cnIgPT09ICc8Jykge1xuICAgICAgICAgIGFwcGVuZCgpXG4gICAgICAgICAgY3VycmVudCA9IGN1cnJcbiAgICAgICAgICBhcHBlbmQoVF9TSUdOKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBqc3ggcHJvcGVydHlcbiAgICAgICAgLy8gYC1gIGluIGRhdGEtcHJvcFxuICAgICAgICBpZiAobmV4dCA9PT0gJy0nICAmJiAhaW5TdHJpbmdDb250ZW50KCkgJiYgIWluSnN4TGl0ZXJhbHMoKSkge1xuICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBhcHBlbmQoVF9QUk9QRVJUWSwgY3VycmVudCArIGN1cnIgKyBuZXh0KVxuICAgICAgICAgICAgaSArPSAxXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBgPWAgaW4gcHJvcGVydHk9PHZhbHVlPlxuICAgICAgICBpZiAobmV4dCA9PT0gJz0nICYmICFpblN0cmluZ0NvbnRlbnQoKSkge1xuICAgICAgICAgIGNvbnN0IHByb3AgPSBjdXJyZW50ID8gKGN1cnJlbnQgKyBjdXJyKSA6IGN1cnJcbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyKHByb3ApKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gcHJvcFxuICAgICAgICAgICAgYXBwZW5kKFRfUFJPUEVSVFkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBpdCdzIG5vdCBpbiBhIGpzeCB0YWcgZGVjbGFyYXRpb24gb3IgYSBzdHJpbmcsIGNsb3NlIGNoaWxkIGlmIG5leHQgaXMganN4IGNsb3NlIHRhZ1xuICAgIGlmICghX19qc3hUYWcgJiYgKGN1cnIgPT09ICc8JyAmJiBpc0lkZW50aWZpZXJDaGFyKG5leHQpIHx8IGNfbiA9PT0gJzwvJykpIHtcbiAgICAgIF9fanN4VGFnID0gbmV4dCA9PT0gJy8nID8gMiA6IDFcblxuICAgICAgLy8gY3VycmVudCBhbmQgbmV4dCBjaGFyIGNhbiBmb3JtIGEganN4IG9wZW4gb3IgY2xvc2UgdGFnXG4gICAgICBpZiAoY3VyciA9PT0gJzwnICYmIChuZXh0ID09PSAnLycgfHwgaXNBbHBoYShuZXh0KSkpIHtcbiAgICAgICAgX19qc3hFbnRlciA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpc1F1b3RhdGlvbkNoYXIgPSBpc1N0cmluZ1F1b3RhdGlvbihjdXJyKVxuICAgIGNvbnN0IGlzU3RyaW5nVGVtcGxhdGVMaXRlcmFscyA9IGluU3RyVGVtcGxhdGVMaXRlcmFscygpXG4gICAgY29uc3QgaXNSZWdleENoYXIgPSAhX19qc3hFbnRlciAmJiBpc1JlZ2V4U3RhcnQoY19uKVxuICAgIGNvbnN0IGlzSnN4TGl0ZXJhbHMgPSBpbkpzeExpdGVyYWxzKClcblxuICAgIC8vIHN0cmluZyBxdW90YXRpb25cbiAgICBpZiAoaXNRdW90YXRpb25DaGFyIHx8IGlzU3RyaW5nVGVtcGxhdGVMaXRlcmFscyB8fCBpc1NpbmdsZVF1b3RlcyhfX3N0clF1b3RlKSkge1xuICAgICAgY3VycmVudCArPSBjdXJyXG4gICAgfSBlbHNlIGlmIChpc1JlZ2V4Q2hhcikge1xuICAgICAgYXBwZW5kKClcbiAgICAgIGNvbnN0IFtsYXN0VHlwZSwgbGFzdFRva2VuXSA9IGxhc3RcbiAgICAgIC8vIFNwZWNpYWwgY2FzZXMgdGhhdCBhcmUgbm90IGNvbnNpZGVyZWQgYXMgcmVnZXg6XG4gICAgICAvLyAqIChleHByMSkgLyBleHByMjogYClgIGJlZm9yZSBgL2Agb3BlcmF0b3IgaXMgc3RpbGwgaW4gZXhwcmVzc2lvblxuICAgICAgLy8gKiA8bm9uIGNvbW1lbnQgc3RhcnQ+LyBleHByOiBub24gY29tbWVudCBzdGFydCBiZWZvcmUgYC9gIGlzIG5vdCByZWdleFxuICAgICAgaWYgKFxuICAgICAgICBpc1JlZ2V4Q2hhciAmJlxuICAgICAgICBsYXN0VHlwZSAhPT0gLTEgJiZcbiAgICAgICAgIShcbiAgICAgICAgICAobGFzdFR5cGUgPT09IFRfU0lHTiAmJiAnKScgIT09IGxhc3RUb2tlbikgfHxcbiAgICAgICAgICBsYXN0VHlwZSA9PT0gVF9DT01NRU5UXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50ID0gY3VyclxuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFydCA9IGkrK1xuXG4gICAgICAvLyBlbmQgb2YgbGluZSBvZiBlbmQgb2YgZmlsZVxuICAgICAgY29uc3QgaXNFb2YgPSAoKSA9PiBpID49IGNvZGUubGVuZ3RoXG4gICAgICBjb25zdCBpc0VvbCA9ICgpID0+IGlzRW9mKCkgfHwgY29kZVtpXSA9PT0gJ1xcbidcblxuICAgICAgbGV0IGZvdW5kQ2xvc2UgPSBmYWxzZVxuICAgICAgLy8gcmVnZXhcbiAgICAgIGZvciAoOyAhaXNFb2woKTsgaSsrKSB7XG4gICAgICAgIGlmIChjb2RlW2ldID09PSAnLycgJiYgY29kZVtpIC0gMV0gIT09ICdcXFxcJykge1xuICAgICAgICAgIGZvdW5kQ2xvc2UgPSB0cnVlXG4gICAgICAgICAgLy8gYXBwZW5kIHJlZ2V4IGZsYWdzXG4gICAgICAgICAgd2hpbGUgKHN0YXJ0ICE9PSBpICYmIC9eW2Etel0kLy50ZXN0KGNvZGVbaSArIDFdKSAmJiAhaXNFb2woKSkge1xuICAgICAgICAgICAgaSsrXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPT0gaSAmJiBmb3VuZENsb3NlKSB7XG4gICAgICAgIC8vIElmIGN1cnJlbnQgbGluZSBpcyBmdWxseSBjbG9zZWQgd2l0aCBzdHJpbmcgcXVvdGVzIG9yIHJlZ2V4IHNsYXNoZXMsXG4gICAgICAgIC8vIGFkZCB0aGVtIHRvIHRva2Vuc1xuICAgICAgICBjdXJyZW50ID0gY29kZS5zbGljZShzdGFydCwgaSArIDEpXG4gICAgICAgIGFwcGVuZChUX1NUUklORylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgbWF0Y2ggYW55IG9mIHRoZSBhYm92ZSwganVzdCBsZWF2ZSBpdCBhcyBvcGVyYXRvciBhbmQgbW92ZSBvblxuICAgICAgICBjdXJyZW50ID0gY3VyclxuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBpID0gc3RhcnRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQ29tbWVudFN0YXJ0KGNfbikpIHtcbiAgICAgIGFwcGVuZCgpXG4gICAgICBjb25zdCBzdGFydCA9IGlcbiAgICAgIGlmIChuZXh0ID09PSAnLycpIHtcbiAgICAgICAgZm9yICg7IGkgPCBjb2RlLmxlbmd0aCAmJiBjb2RlW2ldICE9PSAnXFxuJzsgaSsrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgY29kZS5sZW5ndGggJiYgY29kZVtpIC0gMV0gKyBjb2RlW2ldICE9PSAnKi8nOyBpKyspO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGNvZGUuc2xpY2Uoc3RhcnQsIGkgKyAxKVxuICAgICAgYXBwZW5kKFRfQ09NTUVOVClcbiAgICB9IGVsc2UgaWYgKGN1cnIgPT09ICcgJyB8fCBjdXJyID09PSAnXFxuJykge1xuICAgICAgaWYgKFxuICAgICAgICBjdXJyID09PSAnICcgJiZcbiAgICAgICAgKFxuICAgICAgICAgIChpc1NwYWNlcyhjdXJyZW50KSB8fCAhY3VycmVudCkgfHxcbiAgICAgICAgICBpc0pzeExpdGVyYWxzXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50ICs9IGN1cnJcbiAgICAgICAgaWYgKG5leHQgPT09ICc8Jykge1xuICAgICAgICAgIGFwcGVuZCgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgIGFwcGVuZCgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfX2pzeEV4cHIgJiYgY3VyciA9PT0gJ30nKSB7XG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIF9fanN4RXhwciA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAvLyBpdCdzIGpzeCBsaXRlcmFscyBhbmQgaXMgbm90IGEganN4IGJyYWNrZXRcbiAgICAgICAgKGlzSnN4TGl0ZXJhbHMgJiYgIWpzeEJyYWNrZXRzLmhhcyhjdXJyKSkgfHxcbiAgICAgICAgLy8gc2FtZSB0eXBlIGNoYXIgYXMgcHJldmlvdXMgb25lIGluIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgKChpc1dvcmQoY3VycikgPT09IGlzV29yZChjdXJyZW50W2N1cnJlbnQubGVuZ3RoIC0gMV0pIHx8IF9fanN4Q2hpbGQoKSkgJiYgIXNpZ25zLmhhcyhjdXJyKSlcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50ICs9IGN1cnJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwX2MgPT09ICc8LycpIHtcbiAgICAgICAgICBjdXJyZW50ID0gcF9jXG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kKClcblxuICAgICAgICBpZiAocF9jICE9PSAnPC8nKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJcblxuICAgICAgICB9XG4gICAgICAgIGlmICgoY19uID09PSAnPC8nIHx8IGNfbiA9PT0gJy8+JykpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY19uXG4gICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgICBpKytcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqc3hCcmFja2V0cy5oYXMoY3VycikpIGFwcGVuZCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXBwZW5kKClcblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxbbnVtYmVyLCBzdHJpbmddPn0gdG9rZW5zXG4gKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZSh0b2tlbnMpIHtcbiAgY29uc3QgbGluZXMgPSBbXVxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGNoaWxkcmVuXG4gICAqIFxuICAgKi9cbiAgY29uc3QgY3JlYXRlTGluZSA9IChjaGlsZHJlbikgPT4gXG4gICAgLy8gZ2VuZXJhdGVUeXBlID09PSAnaHRtbCdcbiAgICAgIC8vID8gYDxzcGFuIGNsYXNzPVwic2hfX2xpbmVcIj4ke2NvbnRlbnR9PC9zcGFuPmBcbiAgICAgICh7XG4gICAgICAgIHR5cGU6ICdlbGVtZW50JyxcbiAgICAgICAgdGFnTmFtZTogJ3NwYW4nLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGNsYXNzTmFtZTogJ3NoX19saW5lJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8W251bWJlciwgc3RyaW5nXT59IHRva2Vuc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIGZsdXNoTGluZSh0b2tlbnMpIHtcbiAgICAvKiogQHR5cGUge0FycmF5PGFueT59ICovXG4gICAgY29uc3QgbGluZVRva2VucyA9IChcbiAgICAgIHRva2Vuc1xuICAgICAgICAubWFwKChbdHlwZSwgdmFsdWVdKSA9PiAoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3NwYW4nLFxuICAgICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLCAvLyB0byBlbmNvZGVcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IGBzaF9fdG9rZW4tLSR7dHlwZXNbdHlwZV19YCxcbiAgICAgICAgICAgICAgc3R5bGU6IGBjb2xvcjogdmFyKC0tc2gtJHt0eXBlc1t0eXBlXX0pYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuICAgICAgICApKVxuICAgIClcbiAgICBsaW5lcy5wdXNoKGNyZWF0ZUxpbmUobGluZVRva2VucykpXG4gIH1cbiAgLyoqIEB0eXBlIHtBcnJheTxbbnVtYmVyLCBzdHJpbmddPn0gKi9cbiAgY29uc3QgbGluZVRva2VucyA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICBjb25zdCBbdHlwZSwgdmFsdWVdID0gdG9rZW5cbiAgICBpZiAodHlwZSAhPT0gVF9CUkVBSykge1xuICAgICAgLy8gRGl2aWRlIG11bHRpLWxpbmUgdG9rZW4gaW50byBtdWx0aS1saW5lIGNvZGVcbiAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSB2YWx1ZS5zcGxpdCgnXFxuJylcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxpbmVUb2tlbnMucHVzaChbdHlwZSwgbGluZXNbal1dKVxuICAgICAgICAgIGlmIChqIDwgbGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZmx1c2hMaW5lKGxpbmVUb2tlbnMpXG4gICAgICAgICAgICBsaW5lVG9rZW5zLmxlbmd0aCA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmVUb2tlbnMucHVzaCh0b2tlbilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGluZVRva2Vucy5wdXNoKFt0eXBlLCAnJ10pXG4gICAgICBmbHVzaExpbmUobGluZVRva2VucylcbiAgICAgIGxpbmVUb2tlbnMubGVuZ3RoID0gMFxuICAgIH1cbiAgfVxuXG4gIGlmIChsaW5lVG9rZW5zLmxlbmd0aClcbiAgICBmbHVzaExpbmUobGluZVRva2VucylcblxuICByZXR1cm4gbGluZXNcbn1cblxuZnVuY3Rpb24gdG9IdG1sKGxpbmVzKSB7XG4gIHJldHVybiBsaW5lc1xuICAgIC5tYXAobGluZSA9PiB7XG4gICAgICBjb25zdCB7IHRhZ05hbWU6IGxpbmVUYWcgfSA9IGxpbmVcbiAgICAgIGNvbnN0IHRva2VucyA9IGxpbmUuY2hpbGRyZW5cbiAgICAgICAgLm1hcChjaGlsZCA9PiB7XG4gICAgICAgICAgY29uc3QgeyB0YWdOYW1lLCBjaGlsZHJlbiwgcHJvcGVydGllcyB9ID0gY2hpbGRcbiAgICAgICAgICByZXR1cm4gYDwke3RhZ05hbWV9IGNsYXNzPVwiJHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuY2xhc3NOYW1lXG4gICAgICAgICAgfVwiIHN0eWxlPVwiJHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuc3R5bGVcbiAgICAgICAgICB9XCI+JHtlbmNvZGUoY2hpbGRyZW5bMF0udmFsdWUpfTwvJHt0YWdOYW1lfT5gXG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcnKVxuICAgICAgcmV0dXJuIGA8JHtsaW5lVGFnfSBjbGFzcz1cIiR7bGluZS5wcm9wZXJ0aWVzLmNsYXNzTmFtZX1cIj4ke3Rva2Vuc308LyR7bGluZVRhZ30+YFxuICAgIH0pXG4gICAgLmpvaW4oJ1xcbicpXG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoaWdobGlnaHQoY29kZSkge1xuICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShjb2RlKVxuICBjb25zdCBsaW5lcyA9IGdlbmVyYXRlKHRva2VucylcbiAgY29uc3Qgb3V0cHV0ID0gdG9IdG1sKGxpbmVzKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbi8vIG5hbWVzcGFjZVxuY29uc3QgU3VnYXJIaWdoID0gLyoqIEB0eXBlIHtjb25zdH0gKi8ge1xuICBUb2tlblR5cGVzOiB0eXBlcyxcbiAgVG9rZW5NYXA6IG5ldyBNYXAodHlwZXMubWFwKCh0eXBlLCBpKSA9PiBbdHlwZSwgaV0pKSxcbn1cblxuZXhwb3J0IHtcbiAgaGlnaGxpZ2h0LFxuICB0b2tlbml6ZSxcbiAgZ2VuZXJhdGUsXG4gIFN1Z2FySGlnaCxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sugar-high/lib/index.js\n");

/***/ })

};
;